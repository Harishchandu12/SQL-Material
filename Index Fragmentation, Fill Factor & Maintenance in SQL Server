ðŸ“˜ Index Fragmentation, Fill Factor & Maintenance in SQL Server

ðŸ”¹ 1. Introduction

Indexes improve query performance, but over time DML operations (INSERT, UPDATE, DELETE) can cause index fragmentation, which can degrade performance.

Key concepts:

Fragmentation â†’ indexes become inefficient, causing extra I/O.

Fill Factor â†’ controls how much space is left in index pages during creation/rebuild.

Maintenance â†’ reorganizing or rebuilding indexes restores performance.

ðŸ”¹ 2. Index Fragmentation
ðŸ§© Definition

Index fragmentation occurs when the logical order of pages in an index does not match the physical order on disk.

Impact:

Slower reads and scans.

Higher I/O cost.

Poor query performance, especially for range queries.

ðŸ”¹ 2.1 Types of Fragmentation
Type	Description	Example
Internal Fragmentation	Wasted space inside index pages (pages not fully filled)	Many free slots in a page after DELETE operations
External Fragmentation	Logical order of pages differs from physical order on disk	Sequential read requires jumping across pages
ðŸ”¹ 2.2 How Fragmentation Happens

INSERT into full pages â†’ page splits â†’ logical order broken

DELETE â†’ pages partially empty â†’ internal fragmentation

UPDATE â†’ increases row size â†’ may cause row migration

ðŸ”¹ 3. Fill Factor
ðŸ§© Definition

Fill Factor is a setting that controls percentage of space filled in each index page during creation or rebuild.

Value range: 0â€“100

100% â†’ pages fully filled (default, no free space)

80% â†’ 20% free space for future growth

Purpose:

Reduce page splits during inserts/updates.

Balance read performance (more full pages) vs write performance (page splits).

ðŸ”¹ 3.1 Example: Creating Index with Fill Factor
CREATE NONCLUSTERED INDEX IX_Employees_LastName
ON Employees(LastName)
WITH (FILLFACTOR = 80);


Explanation:

Leaves 20% free space per page.

Reduces page splits on new inserts.

Slightly increases storage and scan time.

ðŸ”¹ 3.2 Best Practices for Fill Factor

OLTP systems â†’ 70â€“90% (frequent inserts/updates)

Read-heavy OLAP systems â†’ 90â€“100% (less frequent modifications)

Avoid very low fill factor â†’ wastes disk space, reduces read efficiency

Monitor and adjust periodically based on fragmentation reports

ðŸ”¹ 4. Detecting Index Fragmentation
ðŸ§© SQL Server DMV Method
SELECT
    dbschemas.[name] AS SchemaName,
    dbtables.[name] AS TableName,
    dbindexes.[name] AS IndexName,
    indexstats.avg_fragmentation_in_percent,
    indexstats.page_count
FROM sys.dm_db_index_physical_stats(DB_ID(), NULL, NULL, NULL, 'LIMITED') AS indexstats
JOIN sys.tables dbtables ON dbtables.[object_id] = indexstats.[object_id]
JOIN sys.schemas dbschemas ON dbtables.[schema_id] = dbschemas.[schema_id]
JOIN sys.indexes dbindexes ON dbindexes.[object_id] = indexstats.[object_id]
                             AND dbindexes.index_id = indexstats.index_id
WHERE indexstats.page_count > 100
ORDER BY indexstats.avg_fragmentation_in_percent DESC;


Key Columns:

avg_fragmentation_in_percent â†’ % logical fragmentation

page_count â†’ number of pages in the index

ðŸ”¹ 4.1 Interpretation
avg_fragmentation_in_percent	Action
0â€“10%	Healthy, no action needed
10â€“30%	Consider reorganizing index
>30%	Consider rebuilding index
ðŸ”¹ 5. Index Maintenance
ðŸ”¹ 5.1 Reorganize vs Rebuild
Operation	Description	Usage	Lock Type	Performance Impact
REORGANIZE	Defragments leaf-level pages, physically rearranges	Low fragmentation (10â€“30%)	ONLINE, row/page level	Light, slower than rebuild for large tables
REBUILD	Drops and recreates index	High fragmentation (>30%)	Can be ONLINE (Enterprise)	Heavy, faster for large tables
ðŸ”¹ 5.2 Syntax Examples
REORGANIZE Index
ALTER INDEX IX_Employees_LastName
ON Employees
REORGANIZE;

REBUILD Index
ALTER INDEX IX_Employees_LastName
ON Employees
REBUILD
WITH (FILLFACTOR = 80, ONLINE = ON);

ðŸ”¹ 5.3 Rebuild vs Drop/Create

Rebuild = drop + create internally (preserves permissions, constraints)

Drop/Create = manual, requires recreating constraints, triggers

ðŸ”¹ 6. Automating Index Maintenance

SQL Server Maintenance Plans

Rebuild indexes automatically on schedule

Reorganize indexes based on fragmentation thresholds

Custom Script Example

DECLARE @tableName NVARCHAR(255);
DECLARE @sql NVARCHAR(MAX);

DECLARE table_cursor CURSOR FOR
SELECT [name] FROM sys.tables;

OPEN table_cursor;
FETCH NEXT FROM table_cursor INTO @tableName;

WHILE @@FETCH_STATUS = 0
BEGIN
    SET @sql = N'ALTER INDEX ALL ON ' + QUOTENAME(@tableName) + ' REBUILD WITH (FILLFACTOR = 80, ONLINE = ON);';
    EXEC sp_executesql @sql;
    FETCH NEXT FROM table_cursor INTO @tableName;
END

CLOSE table_cursor;
DEALLOCATE table_cursor;


Rebuilds all indexes with FILLFACTOR 80, online, automatically.

Can be scheduled as SQL Agent Job.

ðŸ”¹ 7. Best Practices
Area	Recommendation
Monitor Fragmentation	Use sys.dm_db_index_physical_stats regularly
Thresholds	Reorganize 10â€“30%, Rebuild >30%
Fill Factor	Adjust based on workload (OLTP vs OLAP)
Schedule Maintenance	Off-peak hours for large tables
Combine Index Maintenance & Statistics Update	Improves query plans
Avoid Over-indexing	Too many indexes increase maintenance overhead
Partitioned Tables	Maintain indexes per partition for very large tables
ðŸ”¹ 8. Statistics and Query Performance

Index fragmentation affects query optimizer.

Out-of-date statistics cause suboptimal execution plans.

Recommended command to update statistics:

UPDATE STATISTICS Employees WITH FULLSCAN;


Often combined with index maintenance jobs.

ðŸ”¹ 9. Real-World Example
-- Step 1: Check fragmentation
SELECT index_id, avg_fragmentation_in_percent
FROM sys.dm_db_index_physical_stats(DB_ID(), OBJECT_ID('Employees'), NULL, NULL, 'LIMITED');

-- Step 2: Reorganize indexes with 15â€“30% fragmentation
ALTER INDEX IX_Employees_LastName
ON Employees
REORGANIZE;

-- Step 3: Rebuild indexes with >30% fragmentation
ALTER INDEX IX_Employees_LastName
ON Employees
REBUILD WITH (FILLFACTOR = 80, ONLINE = ON);

-- Step 4: Update statistics
UPDATE STATISTICS Employees WITH FULLSCAN;


âœ… Workflow ensures:

Fragmentation is minimized.

Queries run faster.

Storage is optimized.

ðŸ”¹ 10. Quick Summary Table
Concept	Definition	Threshold / Usage	Command
Internal Fragmentation	Wasted space inside pages	Reorganize	ALTER INDEX ... REORGANIZE
External Fragmentation	Logical vs physical page order mismatch	Rebuild	ALTER INDEX ... REBUILD
Fill Factor	% page filled during index creation	70â€“90% OLTP	WITH (FILLFACTOR = 80)
Reorganize	Lightweight defrag, online	10â€“30%	ALTER INDEX ... REORGANIZE
Rebuild	Heavy, recreates index	>30%	ALTER INDEX ... REBUILD
Statistics Update	Updates optimizer info	Regular basis	UPDATE STATISTICS ... WITH FULLSCAN
ðŸ”¹ 11. Interview / Production Q&A
Question	Answer
What is index fragmentation?	Logical or physical disorder in index pages
Types of fragmentation?	Internal and External
Fill factor default?	100% if not specified
When to reorganize vs rebuild?	10â€“30% reorganize, >30% rebuild
How does fill factor help?	Leaves free space to reduce page splits
How often to maintain indexes?	Based on fragmentation, table size, DML workload
Commands to check fragmentation?	sys.dm_db_index_physical_stats
Online vs Offline rebuild?	Online = available during rebuild (Enterprise edition)

âœ… In Summary

Index fragmentation slows down queries.

Fill factor balances page fullness and future inserts.

Reorganize/Rebuild maintain index health.

Regular maintenance + stats updates = optimal performance for OLTP and OLAP systems.
